# Middle Man
## (a.) ความหมายของ Middle Man
เป็น class ที่รับคำสั่งมาแล้วมอบหมายงานให้ class อื่น ๆ ( delegate ) และไม่มี function การทำงานที่เป็นอิสระ ซึ่ง method ส่วนใหญ่ของ class นี้จะเรียกใช้ method ของ class อื่น โดย Middle man smell เกิดจากการปรับปรุงโครงสร้างโค้ด ( refactoring )

### ลักษณะของ Middle Man
- method ในคลาส A แค่เรียก method เดียวกันของคลาส B
- ไม่มี logic เพิ่ม ไม่มีการแปลงข้อมูล
- ถ้าเอาคลาสนี้ออก โค้ดยังสามารถอ่านเข้าใจได้

## (b.) ตัวอย่างโค้ดที่เกิด Middle Man
### ตัวอย่าง Middle Man (Java)
โครงสร้าง
- OrderService -> แค่ส่งต่อไป OrderRepository
- ไม่มี logic อื่นเลย
~~~
class OrderService {
    private OrderRepository repository;

    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }

    public Order findById(int id) {
        // แค่ส่งต่อเฉย ๆ
        return repository.findById(id);
    }
}
~~~
~~~
class OrderRepository {
    public Order findById(int id) {
        // สมมติว่าไป query database
        return new Order(id);
    }
}
~~~
### การใช้งาน
- OrderService ไม่ได้ทำงานอะไรเลย แค่เป็นคนกลางส่งต่อ -> Middle Man
~~~
OrderService service = new OrderService(new OrderRepository());
Order order = service.findById(10);
~~~
## (c.) ตัวอย่างโค้ดที่ refactoring แล้ว
### วิธีที่ 1 Refactor โดย Remove Middle Man
ถ้า OrderService ไม่มี business logic ใด ๆ
-> ลบทิ้งแล้วเรียก Repository ตรง ๆ

หลัง Refactoring ( ไม่มี Middle Man ที่ไม่จำเป็น )
~~~
OrderRepository repository = new OrderRepository();
Order order = repository.findById(1);
~~~

### วิธีที่ 2 Refactor โดยทำให้ Service มีหน้าที่จริง
กรณีอยากเก็บ Service layer ไว้

หลัง Refactoring ( มี validation, มี business rule -> ไม่ใช่ Middle Man แล้ว )
~~~
class OrderService {
    private OrderRepository repository;

    public OrderService(OrderRepository repository) {
        this.repository = repository;
    }

    public Order findById(int id) {
        Order order = repository.findById(id);

        if (order == null) {
            throw new IllegalArgumentException("Order not found: " + id);
        }

        // business logic เพิ่ม
        if (!order.isActive()) {
            throw new IllegalStateException("Order is inactive");
        }

        return order;
    }
}
~~~
## (d.) กรณีที่ middle man นี้ไม่ได้บ่งบอกถึงโค้ดที่มีปัญหา ( กรณีที่ไม่จำเป็นต้อง refactoring )
### 1. ใช้เพื่อ Encapsulation ( ซ่อนโครงสร้างภายใน )
- กรณีที่ไม่อยากให้ client รู้ว่า object ภายในซับซ้อนแค่ไหน สามารถใช้ Middle Man เพื่อช่วยป้องกันการผูกติด ( coupling )
~~~
class Order {
    private Customer customer;

    public String getCustomerName() {
        return customer.getName();
    }
}
~~~
### 2. เป็น Facade / API Boundary
- ชั้นกลางที่ออกแบบมาเพื่อเป็นด่านหน้าให้ระบบอื่น ๆ
~~~
class PaymentFacade {
    public void pay(Order order) {
        paymentService.pay(order);
    }
}
~~~
- ใช้เป็น API ให้ external system
### 3. Layered Architecture (เช่น Controller → Service → Repository)
- Service บางช่วงอาจจะยังไม่มี logic เยอะ
แต่ layer นี้ มีเหตุผลเชิงสถาปัตยกรรม
~~~
class UserService {
    public User findById(int id) {
        return userRepository.findById(id);
    }
}
~~~
- ในอนาคตสามารถใส่ business logic ได้
- ช่วยแยก concern ชัดเจน
### 4. ป้องกัน Law of Demeter
- การเพิ่ม Method กลางช่วยให้ client สื่อสารกันน้อยลง
~~~
person.getManagerName();
~~~
~~~
class Person {
    public String getManagerName() {
        return department.getManager().getName();
    }
}
~~~
- ทำให้โค้ดอ่านง่าย และ coupling ต่ำลง
